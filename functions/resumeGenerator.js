/**
 * Resume & Cover Letter Generator - Cloud Functions Module (server-side)
 */
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const cors = require('cors');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const { OpenAI } = require('openai');
const { PDFDocument, StandardFonts, rgb } = require('pdf-lib');
let puppeteer = null;
async function getPuppeteer() { if (!puppeteer) puppeteer = await import('puppeteer'); return puppeteer; }
if (!admin.apps.length) admin.initializeApp();
const db = admin.firestore();
const bucket = admin.storage().bucket();
const allowedOrigins = ['https://mexty101.web.app','https://mexty101.firebaseapp.com',/^chrome-extension:\/[a-z0-9]{32}$/i];
const corsMiddleware = cors({ origin: (o,cb)=>{ if(!o) return cb(null,true); const ok=allowedOrigins.some(a=> typeof a==='string'? o===a: a.test(o)); return ok?cb(null,true):cb(new Error('Not allowed by CORS')); }, credentials:true, optionsSuccessStatus:200 });
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const safe = (v,d='')=> typeof v==='string'? v: d; const nowIso = ()=> new Date().toISOString();
async function getUserProfile(userId){ const snap=await db.collection('profiles').doc(userId).get(); if(!snap.exists) throw new Error('Profile not found'); return snap.data(); }
function resumePrompt(profile, job){ const skills=Array.isArray(profile.skills)? profile.skills.join(', '): safe(profile.skills); const exp=Array.isArray(profile.experience)? JSON.stringify(profile.experience): safe(profile.experience); const edu=Array.isArray(profile.education)? JSON.stringify(profile.education): safe(profile.education); return `Return JSON only with keys: summary, skills[], experience[{title,company,start,end,achievements[]}], education[{school,degree,start,end}].\nTarget: ${safe(job.jobTitle)} at ${safe(job.companyName)}\nJD: ${safe(job.jobDescription)}\nCandidate name:${safe(profile.name)} title:${safe(profile.title)} summary:${safe(profile.summary)} skills:${skills} exp:${exp} edu:${edu}`; }
function coverPrompt(profile, job){ return `Write a <350 word, professional, human cover letter for ${safe(job.jobTitle)} at ${safe(job.companyName)}. JD:${safe(job.jobDescription)}. Candidate ${safe(profile.name)} (${safe(profile.title)}). Core skills: ${Array.isArray(profile.skills)? profile.skills.join(', '): safe(profile.skills)}. Return plain text.`; }
async function callAIJSON({model='gemini', prompt}){ if(model==='gemini'){ const m=genAI.getGenerativeModel({model:'gemini-1.5-flash'}); const r=await m.generateContent([{text: prompt+'\nJSON only.'}]); return JSON.parse(await r.response.text()); } if(model==='openai'){ const c=await openai.chat.completions.create({ model:'gpt-4o-mini', messages:[{role:'system',content:'Return valid JSON only.'},{role:'user',content:prompt}], temperature:0.4, max_tokens:1800 }); return JSON.parse(c.choices?.[0]?.message?.content||'{}'); } throw new Error('Unsupported model'); }
async function callAIText({model='gemini', prompt}){ if(model==='gemini'){ const m=genAI.getGenerativeModel({model:'gemini-1.5-flash'}); const r=await m.generateContent([{text:prompt}]); return r.response.text(); } if(model==='openai'){ const c=await openai.chat.completions.create({ model:'gpt-4o-mini', messages:[{role:'user',content:prompt}], temperature:0.6, max_tokens:800 }); return c.choices?.[0]?.message?.content||''; } throw new Error('Unsupported model'); }
function renderResumeHTML(data, profile, job, prefs={}){ const primary=prefs.primaryColor||'#0f172a'; const accent=prefs.accentColor||'#0891b2'; const font=prefs.fontFamily||'Arial, Helvetica, sans-serif'; const skills=(data.skills||[]).map(s=>`<span class="chip">${s}</span>`).join(' '); const exp=(data.experience||[]).map(e=>`<div class="exp-item"><div class="row"><strong>${e.title||''}</strong> • ${e.company||''}</div><div class="sub">${e.start||''} – ${e.end||'Present'}</div><ul>${(e.achievements||[]).map(a=>`<li>${a}</li>`).join('')}</ul></div>`).join(''); const edu=(data.education||[]).map(ed=>`<div class="edu-item"><div class="row"><strong>${ed.degree||''}</strong> • ${ed.school||''}</div><div class="sub">${ed.start||''} – ${ed.end||''}</div></div>`).join(''); return `<!doctype html><html><head><meta charset="utf-8"/><style>body{font-family:${font};color:#0b1021;margin:32px}h1{margin:0 0 4px;color:${primary}}h2{color:${primary};border-bottom:2px solid ${primary};padding-bottom:4px;margin-top:18px}.header{display:flex;justify-content:space-between;align-items:baseline}.meta{color:#334155}.chip{display:inline-block;background:${accent}20;color:${primary};padding:4px 8px;border-radius:12px;margin:2px 6px 2px 0;font-size:12px}ul{margin:6px 0 0 18px}.row{display:flex;justify-content:space-between}.sub{color:#475569;font-size:12px}.section{page-break-inside:avoid}</style></head><body><div class="header"><div><h1>${safe(profile.name)}</h1><div class="meta">${safe(profile.title)} • ${safe(profile.email)} • ${safe(profile.phone)}</div><div class="meta">${safe(profile.location||'')}</div></div><div class="meta">${safe(job.jobTitle)} @ ${safe(job.companyName)}</div></div><div class="section"><h2>Professional Summary</h2><p>${safe(data.summary)}</p></div><div class="section"><h2>Skills</h2><div>${skills}</div></div><div class="section"><h2>Experience</h2>${exp}</div><div class="section"><h2>Education</h2>${edu}</div></body></html>`; }
function renderCoverHTML(text, profile, job, prefs={}){ const font=prefs.fontFamily||'Georgia, serif'; return `<!doctype html><html><head><meta charset="utf-8"/><style>body{font-family:${font};margin:48px;line-height:1.6;color:#0b1021}h1{font-size:18px;margin:0 0 8px}.meta{color:#475569;font-size:13px;margin-bottom:24px}.sign{margin-top:24px}</style></head><body><h1>Cover Letter</h1><div class="meta">${safe(profile.name)} • ${safe(profile.email)} • ${safe(profile.phone)}</div><div class="meta">Target: ${safe(job.jobTitle)} at ${safe(job.companyName)}</div><p>${text.replace(/\n/g,'<br/>')}</p><div class="sign">Regards,<br/>${safe(profile.name)}</div></body></html>`; }
async function htmlToPdfBuffer(html){ try{ const {default:pptr}=await getPuppeteer(); const browser=await pptr.launch({args:['--no-sandbox','--disable-setuid-sandbox']}); const page=await browser.newPage(); await page.setContent(html,{waitUntil:'networkidle0'}); const buf=await page.pdf({format:'A4',printBackground:true,margin:{top:'16mm',bottom:'16mm',left:'14mm',right:'14mm'}}); await browser.close(); return buf; } catch(e){ const pdf=await PDFDocument.create(); const p=pdf.addPage(); const font=await pdf.embedFont(StandardFonts.Helvetica); const text=html.replace(/<[^>]+>/g,''); p.drawText(text.slice(0,6000),{x:50,y:p.getHeight()-50,size:12,font,color:rgb(0,0,0)}); return await pdf.save(); } }
async function uploadAndSign({buffer,path,contentType='application/pdf',expiresInHours=24}){ const file=bucket.file(path); await file.save(buffer,{contentType,resumable:false,public:false,metadata:{cacheControl:'private, max-age=0'}}); const [url]=await file.getSignedUrl({action:'read',expires: Date.now()+expiresInHours*3600*1000}); return {url,storagePath:path}; }
async function generateResumeFlow({userId,job,preferences={},model='gemini'}){ const profile=await getUserProfile(userId); const data=await callAIJSON({model,prompt:resumePrompt(profile,job)}); const html=renderResumeHTML(data,profile,job,preferences); const pdfBuffer=await htmlToPdfBuffer(html); const ts=Date.now(); const storagePath=`docs/${userId}/resume_${ts}.pdf`; const signed=await uploadAndSign({buffer:pdfBuffer,path:storagePath}); const docRef=await db.collection('users').doc(userId).collection('documents').add({type:'resume',model,job,preferences,storagePath,url:signed.url,createdAt:admin.firestore.FieldValue.serverTimestamp(),meta:{size:pdfBuffer.length}}); return {documentId:docRef.id,url:signed.url,storagePath,createdAt:nowIso(),type:'resume'}; }
async function generateCoverFlow({userId,job,preferences={},model='gemini'}){ const profile=await getUserProfile(userId); const letter=await callAIText({model,prompt:coverPrompt(profile,job)}); const html=renderCoverHTML(letter,profile,job,preferences); const pdfBuffer=await htmlToPdfBuffer(html); const ts=Date.now(); const storagePath=`docs/${userId}/cover_letter_${ts}.pdf`; const signed=await uploadAndSign({buffer:pdfBuffer,path:storagePath}); const docRef=await db.collection('users').doc(userId).collection('documents').add({type:'cover_letter',model,job,preferences,storagePath,url:signed.url,createdAt:admin.firestore.FieldValue.serverTimestamp(),meta:{size:pdfBuffer.length}}); return {documentId:docRef.id,url:signed.url,storagePath,createdAt:nowIso(),type:'cover_letter'}; }
function validateJob(body){ const job=body.job||{}; return { jobTitle:safe(job.jobTitle), jobDescription:safe(job.jobDescription), companyName:safe(job.companyName) }; }
exports.generateResume = functions.https.onRequest((req,res)=> corsMiddleware(req,res, async ()=>{ if(req.method!=='POST') return res.status(405).json({error:'Method not allowed'}); try{ const {userId,model='gemini',preferences={}}=req.body||{}; if(!userId) return res.status(400).json({error:'userId required'}); const job=validateJob(req.body||{}); const result=await generateResumeFlow({userId,job,preferences,model}); return res.status(200).json(result); } catch(e){ console.error('generateResume error',e); return res.status(500).json({error:'Failed to generate resume',message:e.message}); }}));
exports.generateCoverLetter = functions.https.onRequest((req,res)=> corsMiddleware(req,res, async ()=>{ if(req.method!=='POST') return res.status(405).json({error:'Method not allowed'}); try{ const {userId,model='gemini',preferences={}}=req.body||{}; if(!userId) return res.status(400).json({error:'userId required'}); const job=validateJob(req.body||{}); const result=await generateCoverFlow({userId,job,preferences,model}); return res.status(200).json(result); } catch(e){ console.error('generateCoverLetter error',e); return res.status(500).json({error:'Failed to generate cover letter',message:e.message}); }}));
